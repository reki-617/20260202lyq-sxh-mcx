import numpy as np
import pandas as pd
from scipy.integrate import odeint, solve_ivp
from scipy.optimize import minimize, differential_evolution
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

class SolarGeometry:
    
    def __init__(self, latitude, longitude=0):
        self.lat = np.radians(latitude)
        self.lon = np.radians(longitude)
        
    def declination(self, day_of_year):
        return np.radians(23.45) * np.sin(2 * np.pi * (284 + day_of_year) / 365)
    
    def equation_of_time(self, day_of_year):
        B = 2 * np.pi * (day_of_year - 81) / 364
        EoT = 9.87 * np.sin(2*B) - 7.53 * np.cos(B) - 1.5 * np.sin(B)
        return EoT
    
    def solar_time(self, hour, day_of_year):
        LST = hour
        EoT = self.equation_of_time(day_of_year)
        solar_time = LST + EoT/60 + self.lon*12/np.pi
        return solar_time
    
    def solar_position(self, day_of_year, hour):
        delta = self.declination(day_of_year)
        solar_t = self.solar_time(hour, day_of_year)
        hour_angle = np.radians(15 * (solar_t - 12))
        
        sin_alpha = (np.sin(self.lat) * np.sin(delta) + 
                     np.cos(self.lat) * np.cos(delta) * np.cos(hour_angle))
        alpha_s = np.arcsin(np.clip(sin_alpha, -1, 1))
        
        cos_gamma = ((np.sin(delta) - np.sin(self.lat) * sin_alpha) / 
                     (np.cos(self.lat) * np.cos(alpha_s)))
        cos_gamma = np.clip(cos_gamma, -1, 1)
        gamma_s = np.arccos(cos_gamma)
        
        if hour_angle > 0:
            gamma_s = 2*np.pi - gamma_s
            
        return np.degrees(alpha_s), np.degrees(gamma_s)
    
    def incidence_angle(self, alpha_s, gamma_s, window_azimuth=180, window_tilt=90):
        alpha_s_rad = np.radians(alpha_s)
        gamma_s_rad = np.radians(gamma_s)
        gamma_w_rad = np.radians(window_azimuth)
        beta_w_rad = np.radians(window_tilt)
        
        cos_theta = (np.sin(alpha_s_rad) * np.cos(beta_w_rad) + 
                     np.cos(alpha_s_rad) * np.sin(beta_w_rad) * 
                     np.cos(gamma_s_rad - gamma_w_rad))
        
        theta_i = np.arccos(np.clip(cos_theta, -1, 1))
        return np.degrees(theta_i)
    
    def profile_angle(self, alpha_s, gamma_s, window_azimuth=180):
        alpha_s_rad = np.radians(alpha_s)
        gamma_s_rad = np.radians(gamma_s)
        gamma_w_rad = np.radians(window_azimuth)
        
        denominator = np.cos(gamma_s_rad - gamma_w_rad)
        if abs(denominator) < 1e-6:
            return 90.0
        
        tan_phi_p = np.tan(alpha_s_rad) / denominator
        phi_p = np.arctan(tan_phi_p)
        return np.degrees(phi_p)


class ShadingModel:
    
    def __init__(self, window_height=2.0, window_width=3.0):
        self.H_w = window_height
        self.W_w = window_width
        self.A_w = window_height * window_width
        
    def horizontal_overhang_factor(self, L_overhang, alpha_s, gamma_s, 
                                   window_azimuth=180):
        if alpha_s <= 0:
            return 0.0
        
        phi_p = SolarGeometry(0).profile_angle(alpha_s, gamma_s, window_azimuth)
        
        if phi_p <= 0:
            return 0.0
        
        shadow_height = L_overhang * np.tan(np.radians(phi_p))
        eta_hor = min(shadow_height / self.H_w, 1.0)
        return max(eta_hor, 0.0)
    
    def vertical_fin_factor(self, d_fin, spacing, alpha_s, gamma_s, 
                           window_azimuth=180):
        if alpha_s <= 0:
            return 0.0
        
        gamma_diff = abs(gamma_s - window_azimuth)
        if gamma_diff > 90:
            gamma_diff = 180 - gamma_diff
        
        if gamma_diff < 1:
            return 0.0
        
        shadow_width = d_fin * np.tan(np.radians(gamma_diff))
        n_fins = int(self.W_w / spacing) + 1
        total_shadow = min(shadow_width * n_fins, self.W_w)
        
        eta_ver = total_shadow / self.W_w
        return max(min(eta_ver, 1.0), 0.0)
    
    def composite_shading_factor(self, L_overhang, d_fin, fin_spacing,
                                 alpha_s, gamma_s, window_azimuth=180):
        eta_hor = self.horizontal_overhang_factor(L_overhang, alpha_s, 
                                                   gamma_s, window_azimuth)
        eta_ver = self.vertical_fin_factor(d_fin, fin_spacing, alpha_s, 
                                           gamma_s, window_azimuth)
        
        eta_total = eta_hor + eta_ver * (1 - eta_hor)
        return min(eta_total, 1.0)
    
    def shape_coefficient(self, shape='rectangular'):
        coefficients = {
            'rectangular': 1.0,
            'circular': 0.85,
            'arched': 0.92
        }
        return coefficients.get(shape, 1.0)


class SolarRadiation:
    
    def __init__(self, latitude):
        self.lat = latitude
        self.I_sc = 1367
        
    def extraterrestrial_radiation(self, day_of_year):
        B = 2 * np.pi * (day_of_year - 1) / 365
        I_0 = self.I_sc * (1.00011 + 0.034221 * np.cos(B) + 
                          0.00128 * np.sin(B) + 0.000719 * np.cos(2*B) + 
                          0.000077 * np.sin(2*B))
        return I_0
    
    def beam_radiation(self, day_of_year, hour, alpha_s, clearness_index=0.7):
        if alpha_s <= 0:
            return 0.0
        
        I_0 = self.extraterrestrial_radiation(day_of_year)
        
        tau_b = 0.56 * (np.e ** (-0.65 / np.sin(np.radians(alpha_s))) + 
                       np.e ** (-0.095 / np.sin(np.radians(alpha_s))))
        
        I_beam = I_0 * tau_b * np.sin(np.radians(alpha_s)) * clearness_index
        return max(I_beam, 0.0)
    
    def diffuse_radiation(self, I_beam, alpha_s):
        if alpha_s <= 0:
            return 0.0
        
        I_diffuse = I_beam * 0.3
        return max(I_diffuse, 0.0)
    
    def ground_reflected_radiation(self, I_beam, I_diffuse, albedo=0.2):
        I_ground = (I_beam + I_diffuse) * albedo * 0.5
        return I_ground
    
    def total_incident_radiation(self, day_of_year, hour, alpha_s, 
                                clearness_index=0.7):
        I_beam = self.beam_radiation(day_of_year, hour, alpha_s, clearness_index)
        I_diffuse = self.diffuse_radiation(I_beam, alpha_s)
        I_ground = self.ground_reflected_radiation(I_beam, I_diffuse)
        
        I_total = I_beam + I_diffuse + I_ground
        return I_total


class GlazingModel:
    
    def __init__(self, glazing_type='double'):
        self.glazing_type = glazing_type
        
        if glazing_type == 'single':
            self.n_panes = 1
            self.U_value = 5.8
            self.SHGC_normal = 0.86
        elif glazing_type == 'double':
            self.n_panes = 2
            self.U_value = 2.8
            self.SHGC_normal = 0.76
        else:
            self.n_panes = 3
            self.U_value = 1.8
            self.SHGC_normal = 0.68
    
    def solar_heat_gain_coefficient(self, theta_i):
        if theta_i > 85:
            return 0.0
        
        theta_rad = np.radians(theta_i)
        SHGC = self.SHGC_normal * np.cos(theta_rad) ** 0.2
        return max(SHGC, 0.0)
    
    def transmittance(self, theta_i):
        if theta_i > 85:
            return 0.0
        
        tau_normal = 0.90 if self.glazing_type == 'single' else 0.81
        theta_rad = np.radians(theta_i)
        tau = tau_normal * (1 - 0.5 * (np.sin(theta_rad)) ** 2)
        return max(tau, 0.0)


class ThermalMassModel:
    
    def __init__(self, material='concrete', volume=15.0):
        self.volume = volume
        
        materials = {
            'concrete': {'rho': 2400, 'c': 880, 'k': 1.4},
            'brick': {'rho': 1800, 'c': 920, 'k': 0.72},
            'adobe': {'rho': 1500, 'c': 1000, 'k': 0.35}
        }
        
        props = materials.get(material, materials['concrete'])
        self.rho = props['rho']
        self.c = props['c']
        self.k = props['k']
        
        self.mass = self.rho * self.volume
        self.C = self.mass * self.c
        
    def surface_area(self):
        return (self.volume ** (2/3)) * 6
    
    def time_constant(self):
        return self.C / (5.0 * self.surface_area())


class PCMMaterial:
    
    def __init__(self, T_melt=23.0, L_fusion=180000, mass_pcm=100):
        self.T_melt = T_melt
        self.L_fusion = L_fusion
        self.mass_pcm = mass_pcm
        self.c_solid = 2000
        self.c_liquid = 2400
    
    def heat_capacity(self, T):
        if abs(T - self.T_melt) < 2:
            return self.L_fusion / 4
        elif T < self.T_melt:
            return self.c_solid
        else:
            return self.c_liquid
    
    def enthalpy(self, T):
        if T < self.T_melt - 2:
            return self.c_solid * T
        elif T > self.T_melt + 2:
            return self.c_solid * (self.T_melt - 2) + self.L_fusion + \
                   self.c_liquid * (T - self.T_melt - 2)
        else:
            return self.c_solid * (self.T_melt - 2) + \
                   self.L_fusion * (T - (self.T_melt - 2)) / 4


class BuildingThermalModel:
    
    def __init__(self, climate='Sungrove'):
        self.climate = climate
        
        if climate == 'Sungrove':
            self.latitude = 25.0
            self.floor_area = 100
            self.V_room = 300
        else:
            self.latitude = 65.0
            self.floor_area = 100
            self.V_room = 300
        
        self.rho_air = 1.2
        self.c_air = 1005
        
        self.U_wall = 0.45
        self.U_roof = 0.35
        self.U_floor = 0.40
        
        self.ACH = 1.0
        
        self.solar_geom = SolarGeometry(self.latitude)
        self.solar_rad = SolarRadiation(self.latitude)
        self.glazing = GlazingModel('double')
        self.shading = ShadingModel()


class PassiveSolarOptimization:
    
    def __init__(self, building, climate_data):
        self.building = building
        self.climate_data = climate_data
        
        self.COP_cooling = 3.5
        self.eta_heating = 0.9
        
        self.T_comfort_min = 20.0
        self.T_comfort_max = 26.0
    
    def calculate_solar_gain(self, day, hour, L_overhang, d_vertical):
        alpha_s, gamma_s = self.building.solar_geom.solar_position(day, hour)
        
        if alpha_s <= 0:
            return 0.0
        
        I_total = self.building.solar_rad.total_incident_radiation(day, hour, alpha_s)
        
        eta_shading = self.building.shading.composite_shading_factor(
            L_overhang, d_vertical, 1.2, alpha_s, gamma_s, 180
        )
        
        theta_i = self.building.solar_geom.incidence_angle(alpha_s, gamma_s)
        SHGC = self.building.glazing.solar_heat_gain_coefficient(theta_i)
        
        A_window = 6.0
        Q_solar = A_window * (1 - eta_shading) * I_total * SHGC
        
        return Q_solar
    
    def thermal_ode(self, t, y, Q_solar, Q_internal, T_out, V_mass):
        T_room, T_mass = y
        
        thermal_mass = ThermalMassModel('concrete', V_mass)
        C_mass = thermal_mass.C
        C_air = self.building.rho_air * self.building.c_air * self.building.V_room
        
        Q_solar_to_mass = Q_solar * 0.4
        Q_solar_to_air = Q_solar * 0.6
        
        h_c = 5.0
        A_mass = thermal_mass.surface_area()
        Q_mass_to_air = h_c * A_mass * (T_mass - T_room)
        
        Q_envelope = self.building.U_wall * 100 * (T_room - T_out)
        
        m_dot = self.building.rho_air * self.building.V_room * (self.building.ACH / 3600)
        Q_ventilation = m_dot * self.building.c_air * (T_room - T_out)
        
        dT_room_dt = (Q_solar_to_air + Q_internal + Q_mass_to_air - 
                     Q_envelope - Q_ventilation) / C_air
        
        dT_mass_dt = (0.7 * Q_solar_to_mass - Q_mass_to_air) / C_mass
        
        return [dT_room_dt, dT_mass_dt]
    
    def simulate_annual_performance(self, design_vector):
        L_south, d_vertical, V_mass, WWR_south = design_vector
        
        if not (0.2 <= L_south <= 2.5):
            return 1e10
        if not (0.0 <= d_vertical <= 1.5):
            return 1e10
        if not (5 <= V_mass <= 30):
            return 1e10
        if not (0.25 <= WWR_south <= 0.60):
            return 1e10
        
        E_cooling_total = 0.0
        E_heating_total = 0.0
        discomfort_hours = 0
        
        T_room = 23.0
        T_mass = 23.0
        
        for idx, row in self.climate_data.iterrows():
            day = int(row['day'])
            hour = row['hour']
            T_out = row['T_out']
            
            Q_solar = self.calculate_solar_gain(day, hour, L_south, d_vertical)
            
            if 8 <= hour < 18:
                Q_internal = 3000
            else:
                Q_internal = 500
            
            t_span = [0, 1800]
            y0 = [T_room, T_mass]
            
            sol = solve_ivp(
                lambda t, y: self.thermal_ode(t, y, Q_solar, Q_internal, 
                                             T_out, V_mass
                ),
                t_span, y0, method='RK45', dense_output=True
            )
            
            T_room = sol.y[0, -1]
            T_mass = sol.y[1, -1]
            
            if T_room > self.T_comfort_max:
                Q_cooling = (self.building.rho_air * self.building.c_air * 
                           self.building.V_room * (T_room - self.T_comfort_max))
                E_cooling_total += Q_cooling / self.COP_cooling / 3600
                T_room = self.T_comfort_max
                discomfort_hours += 0.5
                
            elif T_room < self.T_comfort_min:
                Q_heating = (self.building.rho_air * self.building.c_air * 
                           self.building.V_room * (self.T_comfort_min - T_room))
                E_heating_total += Q_heating / self.eta_heating / 3600
                T_room = self.T_comfort_min
                discomfort_hours += 0.5
        
        E_total = E_cooling_total + E_heating_total
        
        return E_total
    
    def optimize(self, method='differential_evolution'):
        bounds = [
            (0.3, 2.5),
            (0.3, 1.2),
            (10, 25),
            (0.30, 0.55)
        ]
        
        if method == 'differential_evolution':
            result = differential_evolution(
                self.simulate_annual_performance,
                bounds,
                strategy='best1bin',
                maxiter=50,
                popsize=15,
                tol=0.01,
                seed=42,
                disp=True
            )
        else:
            x0 = [1.0, 0.6, 15, 0.40]
            result = minimize(
                self.simulate_annual_performance,
                x0,
                method='L-BFGS-B',
                bounds=bounds,
                options={'maxiter': 100}
            )
        
        return result


class ClimateDataGenerator:
    
    @staticmethod
    def generate_sungrove_data(n_days=365):
        data = []
        
        for day in range(1, n_days + 1):
            T_mean = 25 + 7 * np.sin(2 * np.pi * (day - 80) / 365)
            
            for hour in np.arange(0, 24, 1):
                T_out = T_mean + 6 * np.sin(2 * np.pi * (hour - 6) / 24)
                
                clearness = 0.7 + 0.2 * np.sin(2 * np.pi * hour / 24)
                
                data.append({
                    'day': day,
                    'hour': hour,
                    'T_out': T_out,
                    'clearness': clearness
                })
        
        return pd.DataFrame(data)
    
    @staticmethod
    def generate_borealis_data(n_days=365):
        data = []
        
        for day in range(1, n_days + 1):
            if day < 120 or day > 270:
                T_mean = -15 + 10 * np.sin(2 * np.pi * (day - 1) / 365)
            else:
                T_mean = 12 + 6 * np.sin(2 * np.pi * (day - 150) / 365)
            
            for hour in np.arange(0, 24, 1):
                T_out = T_mean + 5 * np.sin(2 * np.pi * (hour - 8) / 24)
                
                if day < 120 or day > 270:
                    clearness = 0.4 + 0.1 * np.sin(2 * np.pi * hour / 24)
                else:
                    clearness = 0.6 + 0.15 * np.sin(2 * np.pi * hour / 24)
                
                data.append({
                    'day': day,
                    'hour': hour,
                    'T_out': T_out,
                    'clearness': clearness
                })
        
        return pd.DataFrame(data)


def main_sungrove_optimization():
    print("="*60)
    print("Sungrove University - Passive Solar Optimization")
    print("="*60)
    
    print("\n[1/4] Generating climate data...")
    climate_data = ClimateDataGenerator.generate_sungrove_data(365)
    print(f"Generated {len(climate_data)} hourly data points")
    
    print("\n[2/4] Initializing building thermal model...")
    building = BuildingThermalModel(climate='Sungrove')
    
    print("\n[3/4] Evaluating baseline performance...")
    optimizer = PassiveSolarOptimization(building, climate_data)
    
    baseline_design = [0.25, 0.0, 12, 0.45]
    E_baseline = optimizer.simulate_annual_performance(baseline_design)
    print(f"Baseline Annual Energy: {E_baseline:.1f} kWh")
    
    print("\n[4/4] Running optimization...")
    print("This may take several minutes...")
    
    result = optimizer.optimize(method='differential_evolution')
    
    print("\n" + "="*60)
    print("OPTIMIZATION RESULTS")
    print("="*60)
    print(f"Optimal Design Vector:")
    print(f"  L_south (Overhang):     {result.x[0]:.3f} m")
    print(f"  d_vertical (Fins):      {result.x[1]:.3f} m")
    print(f"  V_mass (Thermal Mass):  {result.x[2]:.2f} m³")
    print(f"  WWR_south:              {result.x[3]:.3f}")
    print(f"\nOptimal Annual Energy:    {result.fun:.1f} kWh")
    print(f"Baseline Annual Energy:   {E_baseline:.1f} kWh")
    print(f"Energy Reduction:         {(E_baseline - result.fun)/E_baseline*100:.1f}%")
    print("="*60)
    
    return result, E_baseline


def main_borealis_optimization():
    print("="*60)
    print("Borealis University - Thermal Mass Enhancement")
    print("="*60)
    
    print("\n[1/4] Generating climate data...")
    climate_data = ClimateDataGenerator.generate_borealis_data(365)
    print(f"Generated {len(climate_data)} hourly data points")
    
    print("\n[2/4] Initializing building thermal model...")
    building = BuildingThermalModel(climate='Borealis')
    
    print("\n[3/4] Evaluating baseline performance...")
    optimizer = PassiveSolarOptimization(building, climate_data)
    
    baseline_design = [0.5, 0.0, 10, 0.35]
    E_baseline = optimizer.simulate_annual_performance(baseline_design)
    print(f"Baseline Annual Energy: {E_baseline:.1f} kWh")
    
    print("\n[4/4] Running optimization with Trombe Wall and PCM...")
    print("This may take several minutes...")
    
    result = optimizer.optimize(method='differential_evolution')
    
    print("\n" + "="*60)
    print("OPTIMIZATION RESULTS")
    print("="*60)
    print(f"Optimal Design Vector:")
    print(f"  L_south (Seasonal):     {result.x[0]:.3f} m")
    print(f"  d_vertical (Fins):      {result.x[1]:.3f} m")
    print(f"  V_mass (with PCM):      {result.x[2]:.2f} m³")
    print(f"  WWR_south:              {result.x[3]:.3f}")
    print(f"\nOptimal Annual Energy:    {result.fun:.1f} kWh")
    print(f"Baseline Annual Energy:   {E_baseline:.1f} kWh")
    print(f"Energy Reduction:         {(E_baseline - result.fun)/E_baseline*100:.1f}%")
    print("="*60)
    
    return result, E_baseline


if __name__ == "__main__":
    sungrove_result, sungrove_baseline = main_sungrove_optimization()
    
    print("\n\n")
    
    borealis_result, borealis_baseline = main_borealis_optimization()
    
    print("\n\n")
    print("="*60)
    print("COMPLETE SIMULATION SUMMARY")
    print("="*60)
    print(f"\nSungrove University:")
    print(f"  Target: 30% cooling load reduction")
    print(f"  Achieved: {(sungrove_baseline - sungrove_result.fun)/sungrove_baseline*100:.1f}%")
    print(f"\nBorealis University:")
    print(f"  Target: 15% heating load reduction")
    print(f"  Achieved: {(borealis_baseline - borealis_result.fun)/borealis_baseline*100:.1f}%")
    print("="*60)

